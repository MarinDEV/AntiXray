package org.marinndev.others.alternativexray.events;

import com.sk89q.worldedit.bukkit.BukkitWorld;
import com.sk89q.worldedit.math.BlockVector3;
import com.sk89q.worldguard.WorldGuard;
import com.sk89q.worldguard.protection.ApplicableRegionSet;
import com.sk89q.worldguard.protection.managers.RegionManager;
import com.sk89q.worldguard.protection.regions.ProtectedRegion;
import com.sk89q.worldguard.protection.regions.RegionContainer;
import org.bukkit.*;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.metadata.FixedMetadataValue;
import org.bukkit.permissions.PermissionAttachmentInfo;
import org.jetbrains.annotations.Nullable;
import org.marinndev.others.alternativexray.Main;
import org.marinndev.others.alternativexray.SettingsManager;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

public class BlockBreak implements Listener {

    SettingsManager files = SettingsManager.getFiles();
    Main plugin = Main.getPlugin(Main.class);

    @EventHandler
    public void onBreak(BlockBreakEvent e) {
        if(!plugin.checkWorld(e.getBlock().getWorld().getName())){
            return;
        }
        Block block = e.getBlock();
        if(!block.getMetadata("canBeReplaced").isEmpty()){
            return;
        }
        Player breaker = e.getPlayer();
        String biomeName = e.getBlock().getBiome().name();
        biomeName = getClosestConfigBiome(determineBiome(biomeName));
        int blockHeight = block.getY();

        Material replacingMaterial = Material.STONE;
        if(block.getWorld().getEnvironment() == World.Environment.NETHER) {
            replacingMaterial = Material.NETHERRACK;
        }

        HashMap<String, Double> oreChances = getChanceOfOresInRange(blockHeight,biomeName);
        HashMap<String, Double> multipliedOreChances = applyMultipliers(oreChances, breaker, block.getLocation());
        applyIndividualMultipliers(multipliedOreChances,  breaker);
        Material newOre = getRandomOre(multipliedOreChances,biomeName);

        float dir = (float)Math.toDegrees(Math.atan2(breaker.getLocation().getBlockX() - block.getX(), block.getZ() - breaker.getLocation().getBlockZ()));
        BlockFace face = getClosestFace(dir, breaker.getLocation().getPitch());
        Block relativeBlock = block.getRelative(face);

        replaceBlocks(block, replacingMaterial, 2);// Will replace ores with the specified block (stone/netherrack).
        spawnOres(generateOreSize(fromMaterialToString(newOre)), newOre, relativeBlock, face);
        if(!block.getMetadata("canBeReplaced").isEmpty()){// Checks if the block is one generated by the plugin.
            block.removeMetadata("canBeReplaced",plugin);
        }
    }

    public ArrayList<Block> getOresInRadius(Block start, int radius){// Gets the blocks around the specified block.
        ArrayList<Block> blocks = new ArrayList<Block>();
        for(double x = start.getLocation().getX() - radius; x <= start.getLocation().getX() + radius; x++){
            for(double y = start.getLocation().getY() - radius; y <= start.getLocation().getY() + radius; y++){
                for(double z = start.getLocation().getZ() - radius; z <= start.getLocation().getZ() + radius; z++){
                    Location loc = new Location(start.getWorld(), x, y, z);
                    if(loc.getBlock().getType() == Material.COAL_ORE
                            || loc.getBlock().getType() == Material.DIAMOND_ORE
                            || loc.getBlock().getType() == Material.GOLD_ORE
                            || loc.getBlock().getType() == Material.REDSTONE_ORE
                            || loc.getBlock().getType() == Material.LAPIS_ORE
                            || loc.getBlock().getType() == Material.EMERALD_ORE
                            || loc.getBlock().getType() == Material.IRON_ORE
                            || loc.getBlock().getType() == Material.NETHER_QUARTZ_ORE
                            || loc.getBlock().getType() == Material.ANCIENT_DEBRIS
                            || loc.getBlock().getType() == Material.NETHER_GOLD_ORE
                            || loc.getBlock().getType() == Material.COPPER_ORE
                            || loc.getBlock().getType() == Material.DEEPSLATE_IRON_ORE
                            || loc.getBlock().getType() == Material.DEEPSLATE_GOLD_ORE
                            || loc.getBlock().getType() == Material.DEEPSLATE_DIAMOND_ORE
                            || loc.getBlock().getType() == Material.DEEPSLATE_LAPIS_ORE
                            || loc.getBlock().getType() == Material.DEEPSLATE_COAL_ORE
                            || loc.getBlock().getType() == Material.DEEPSLATE_EMERALD_ORE
                            || loc.getBlock().getType() == Material.DEEPSLATE_COPPER_ORE

                    ){
                        blocks.add(loc.getBlock());
                    }
                }
            }
        }
        return blocks;
    }// End getBlocks

    public void replaceBlocks(Block block, Material material, int radius)// Replaces the blocks around a block with the specified material.
    {
        ArrayList<Block> blocks = new ArrayList<>();
        for (Block oreBlock : getOresInRadius(block,radius)) {
            if (validateBlock(oreBlock) && oreBlock.getMetadata("canBeReplaced").isEmpty()
                                        && oreBlock.getMetadata("isProtected").isEmpty()) {
                oreBlock.setType(material);
            }
            for(Block oreBlock2 : getOresInRadius(oreBlock,1))
            {
                if (validateBlock(oreBlock2) && oreBlock2.getMetadata("canBeReplaced").isEmpty()
                                             && oreBlock2.getMetadata("isProtected").isEmpty()) {
                    oreBlock2.setType(material);
                }
            }
        }
    }// End replaceBlocks

    private boolean validateBlock(Block block)// Checks if the block has any contact with an air-block because if it does then it
                                              // should not be removed because it might get noticed by a player.
    {
        if(!block.getRelative(BlockFace.UP).getType().isOccluding() || !block.getRelative(BlockFace.DOWN).getType().isOccluding()
                || !block.getRelative(BlockFace.NORTH).getType().isOccluding()
                || !block.getRelative(BlockFace.SOUTH).getType().isOccluding()
                || !block.getRelative(BlockFace.EAST).getType().isOccluding()
                || !block.getRelative(BlockFace.WEST).getType().isOccluding()){
            return false;
        }
        return true;
    }// End validateBlock

    /**
     * Determines which biome from the possible ones includes the player biome.
     * @param biome
     * @return
     */
    public String determineBiome(String biome){
        if(biome.contains("OCEAN")){
            return "ocean";
        }
        if(biome.contains("FOREST") && !biome.equalsIgnoreCase("CRIMSON_FOREST")
                && !biome.equalsIgnoreCase("WARPED_FOREST")){
            if(biome.contains("HILLS")){
                return "forest_hills";
            }else{
                return "forest";
            }
        }
        if(biome.contains("JUNGLE")){
            if(biome.contains("HILLS")){
                return "jungle_hills";
            }else{
                return "jungle";
            }
        }
        if(biome.contains("TAIGA")){
            if(biome.contains("HILLS") || biome.contains("MOUNTAINS")){
                return "taiga_hills";
            }else{
                return "taiga";
            }
        }
        if(biome.contains("SWAMP")){
            if(biome.contains("HILLS")){
                return "swamp_hills";
            }else{
                return "swamp";
            }
        }
        if(biome.contains("MUSHROOM")){
            return "mushroom_fields";
        }
        if(biome.contains("SAVANNA")){
            if(biome.contains("PLATEAU")){
                return "savanna_plateau";
            }else{
                return "savanna";
            }
        }
        if(biome.contains("PLAINS")){
            return "plains";
        }
        if(biome.contains("DESERT")){
            if(biome.contains("HILLS")){
                return "desert_hills";
            }else{
                return "desert";
            }
        }
        if(biome.contains("BADLANDS")){
            if(biome.contains("PLATEAU")){
                return "badlands_plateau";
            }else{
                return "badlands";
            }
        }
        if(biome.equalsIgnoreCase("WOODED_HILLS") || biome.equalsIgnoreCase("TALL_BIRCH_HILLS")){
            return "forest_hills";
        }
        if(biome.contains("MOUNTAINS")){
            return "mountains";
        }
        if(biome.equalsIgnoreCase("NETHER_WASTES")) return "nether";
        if(biome.equalsIgnoreCase("BASALT_DELTAS")) return "nether";
        if(biome.equalsIgnoreCase("CRIMSON_FOREST")) return "nether";
        if(biome.equalsIgnoreCase("WARPED_FOREST")) return "nether";
        if(biome.equalsIgnoreCase("SOUL_SAND_VALLEY")) return "nether";
        return "default";
    }// End determineBiome

    /**
     * Determines which biomes from the ones in the config resembles "biome" the most.
     * @param biome Biome name
     * @return The new biome name
     */
    public String getClosestConfigBiome(String biome){
        String mode = plugin.getMode();
        for(String key : plugin.getConfig().getConfigurationSection(mode).getKeys(false)){
            if(key.contains(biome) && (plugin.getConfig().getConfigurationSection(mode + "." + biome + ".orelayers") != null)
                                   && (plugin.getConfig().getConfigurationSection(mode + "." + biome + ".orechances") != null)){
                return biome;
            }
        }
        if(biome.contains("_")){
            String[] splitBiome = biome.split("_");
            for(String key : plugin.getConfig().getConfigurationSection(mode).getKeys(false)){
                if(key.toUpperCase().contains((splitBiome[splitBiome.length-2]).toUpperCase())
                        && (plugin.getConfig().getConfigurationSection(mode + "." + key + ".orelayers") != null)
                        && (plugin.getConfig().getConfigurationSection(mode + "." + key + ".orelayers") != null)){
                    return splitBiome[splitBiome.length-2];
                }
            }
        }
        return "default";

    }// End getClosestConfigBiome

    /**
     * Gets the ores that can be spawned as well as highY/lowY for the current Y level.
     * @param blockY
     * @param biome
     * @return
     */
    public HashMap<String, Double> getChanceOfOresInRange(int blockY, String biome)
    {
        HashMap<String, Double> oresInRange = new HashMap<String, Double>();// Stores the ores and highY/lowY to return later.
        @Nullable ConfigurationSection configSection = plugin.getConfig().getConfigurationSection(plugin.getMode() + "." + biome + ".orelayers");

        for(String key : configSection.getKeys(false))// Each key is an ore.
        {
            String oreType = key;
            ArrayList<String> oreHeights = new ArrayList<String>();
            for (String oreHeight : plugin.getConfig().getConfigurationSection(plugin.getMode() + "." + biome + ".orelayers." + key).getKeys(false)) {
                oreHeights.add(oreHeight);
            }
            if (oreHeights.size() == 0) {
                files.logError("There is an issue in the config.yml." + " orelayes should indicate at least one of: " + "lowY / lighY probability of spawn.");
                sendConsole("There is an issue in the config.yml." + " orelayers should indicate at least one of: " + "lowY / lighY probability of spawn.");
                continue;
            } else if (!oreHeights.contains("lowY")) {
                String[] highY = plugin.getConfig().getString(plugin.getMode() + "." + biome + ".orelayers." + key + ".highY").split("-");
                int higher = Integer.parseInt(highY[1]);
                int lower = Integer.parseInt(highY[0]);
                if (blockY >= lower && blockY <= higher) {
                    plugin.saveConfig();
                    if(plugin.getConfig().isSet(plugin.getMode() + "." + biome + ".orechances." + key + ".highY")){
                        Double probability = Double.parseDouble(plugin.getConfig().getString(plugin.getMode() + "." + biome + ".orechances." + key + ".highY"));
                        oresInRange.put(oreType,probability);
                    }else{
                        files.logError("There is an issue in the config.yml. "
                                + "Check: "+ plugin.getMode() + "." + biome + ".orechances." + key + ".highY");
                        sendConsole("There is an issue in the config.yml. "
                                + "Check: "+ plugin.getMode() + "." + biome + ".orechances." + key + ".highY");
                        oresInRange.put(oreType,0d);
                    }
                }
            } else if (!oreHeights.contains("highY")) {
                String[] lowY = plugin.getConfig().getString(plugin.getMode() + "." + biome + ".orelayers." + key + ".lowY").split("-");
                int higher = Integer.parseInt(lowY[1]);
                int lower = Integer.parseInt(lowY[0]);
                if (blockY >= lower && blockY <= higher) {
                    if(plugin.getConfig().isSet(plugin.getMode() + "." + biome + ".orechances." + key + ".lowY")){
                        Double probability = Double.parseDouble(plugin.getConfig().getString(plugin.getMode() + "." + biome + ".orechances." + key + ".lowY"));
                        oresInRange.put(oreType,probability);
                    }else{
                        files.logError("There is an issue in the config.yml. "
                                + "Check: "+ plugin.getMode() + "." + biome + ".orechances." + key + ".lowY");
                        sendConsole("There is an issue in the config.yml. "
                                + "Check: "+ plugin.getMode() + "." + biome + ".orechances." + key + ".lowY");
                        oresInRange.put(oreType,0.0);
                    }
                }
            } else {
                String[] lowY = plugin.getConfig().getString(plugin.getMode() + "." + biome + ".orelayers." + key + ".lowY").split("-");
                String[] highY = plugin.getConfig().getString(plugin.getMode() + "." + biome + ".orelayers." + key + ".highY").split("-");

                int higher = Integer.parseInt(highY[1]);
                int lower = Integer.parseInt(lowY[0]);
                if (blockY >= lower && blockY <= higher) {
                    if (blockY <= Integer.parseInt(lowY[1])) {
                        if(plugin.getConfig().isSet(plugin.getMode() + "." + biome + ".orechances." + key + ".lowY")){
                            Double probability = Double.parseDouble(plugin.getConfig().getString(plugin.getMode() + "." + biome + ".orechances." + key + ".lowY"));
                            oresInRange.put(oreType, probability);
                        }else{
                            files.logError("There is an issue in the config.yml. "
                                    + "Check: "+ plugin.getMode() + "." + biome + ".orechances." + key + ".lowY");
                            sendConsole("There is an issue in the config.yml. "
                                    + "Check: "+ plugin.getMode() + "." + biome + ".orechances." + key + ".lowY");
                            oresInRange.put(oreType,0.0);
                        }
                    } else {
                        try {
                            Double probability = Double.parseDouble(plugin.getConfig().getString(plugin.getMode() + "." + biome + ".orechances." + key + ".highY"));
                            oresInRange.put(oreType, probability);
                        } catch (NullPointerException e) {
                            files.logError("There is an issue in the config.yml. "
                                    + "orechance should be indicated for highY/lowY if highY/lowY have been used in the orelayers."
                                    + "Check: "+ plugin.getMode() + "." + biome + ".orechances." + key + ".lowY");
                            sendConsole("There is an issue in the config.yml. "
                                    + "orechance should be indicated for highY/lowY if highY/lowY have been used in the orelayers."
                                    + "Check: "+ plugin.getMode() + "." + biome + ".orechances." + key + ".lowY");
                            oresInRange.put(oreType,0.0);
                        } catch (NumberFormatException e) {
                            files.logError("There is an issue in the config.yml at "
                                    + plugin.getMode() + "." + biome + ".orechances." + key + ".highY. " + "orechances must be a double.");
                            sendConsole("There is an issue in the config.yml at "
                                    + plugin.getMode() + "." + biome + ".orechances." + key + ".highY. " + "orechances must be a double.");
                            oresInRange.put(oreType,0.0);
                        }
                    }
                }
            }
        }
        return oresInRange;
    }// End getOresInRange

    public HashMap<String,Double> applyMultipliers(HashMap<String,Double> inputs, Player miner, Location location){
        HashMap<String,Double> multipliedValues = inputs;
        double globalMultiplier = 1;
        double playerMultiplier = 1;// multiplier based on permission.
        double regionsMultiplier = 1;// multiplier based on regions.
        HashMap<String, Double> configApplicableRegions = new HashMap<String, Double>();

        if(plugin.getConfig().getKeys(false).contains("global-multiplier")){
            try{
                globalMultiplier = Double.parseDouble(plugin.getConfig().getString("global-multiplier"));
            }catch(NumberFormatException e) {
                files.logError("The global-multiplier variable in the config.yml is not a number.");
                sendConsole("The global-multiplier variable in the config.yml is not a number.");
            }
        }
        if(miner != null) {
            for (PermissionAttachmentInfo permission : miner.getEffectivePermissions()) {
                if (permission.getPermission().startsWith("axray.multiplier.")) {
                    try {
                        double temp = Double.parseDouble(permission.getPermission().replace("axray.multiplier.", ""));
                        if (temp > playerMultiplier) {
                            playerMultiplier = temp;
                        }
                    } catch (NumberFormatException e) {
                    }
                }
            }
        }
        if(plugin.getConfig().getKeys(false).contains("worldguard-multipliers")) {
            for (String configRegion : plugin.getConfig().getConfigurationSection("worldguard-multipliers").getKeys(false)) {
                try {
                    double multiplier = Double.parseDouble(plugin.getConfig().getString("worldguard-multipliers." + configRegion));
                    configApplicableRegions.put(configRegion, multiplier);
                } catch (NumberFormatException e) {
                    files.logError("The value at worldguard-multipliers." + configRegion + " is not a double.");
                    sendConsole("The value at worldguard-multipliers." + configRegion + " is not a double.");
                }
            }
        }
        RegionContainer container = WorldGuard.getInstance().getPlatform().getRegionContainer();
        RegionManager regions = container.get(new BukkitWorld(location.getWorld()));
        ApplicableRegionSet regionsSet = regions.getApplicableRegions(BlockVector3.at(location.getX(),location.getY(),location.getZ()));
        for (Iterator<ProtectedRegion> it = regionsSet.iterator(); it.hasNext(); ) {
            ProtectedRegion region = it.next();
            if(configApplicableRegions.containsKey(region.getId().toLowerCase())
                    && configApplicableRegions.get(region.getId().toLowerCase()) > regionsMultiplier){
                regionsMultiplier = configApplicableRegions.get(region.getId().toLowerCase());
            }
        }
        double total = 0.0;
        for(String key : inputs.keySet()){
            double chance = inputs.get(key);
            total += chance;
            multipliedValues.put(key, chance);
        }
        if(1.0 - total >= 0) {
            if(globalMultiplier == 0 || playerMultiplier == 0 || regionsMultiplier == 0){
                multipliedValues.put("nothing", 0.00 + Integer.MAX_VALUE);
            }else {
                multipliedValues.put("nothing", (1.0 - total) / globalMultiplier / playerMultiplier / regionsMultiplier);
            }
        }else{
            multipliedValues.put("nothing", 0.0);
        }
        return multipliedValues;
    }// End applyMultipliers

    public void applyIndividualMultipliers(HashMap<String, Double> chances, Player miner){
        if(miner != null) {
            for (PermissionAttachmentInfo permission : miner.getEffectivePermissions()) {
                if (permission.getPermission().startsWith("axray.multiplier.")) {
                    try {
                        Double.parseDouble(permission.getPermission().replace("axray.multiplier.", ""));
                    } catch (NumberFormatException e) {
                        String multiplier = permission.getPermission().replace("axray.multiplier.", "");
                        String[] split = multiplier.split("\\.");
                        for(String oreType : chances.keySet()){
                            if(!split[0].equalsIgnoreCase(oreType)) continue;
                            if(split.length == 2){
                                try{
                                    Double mp = Double.parseDouble(split[1]);
                                    Double chance = chances.get(oreType);
                                    chance = chance*mp;
                                    chances.put(oreType,chance);
                                }catch(NumberFormatException ex){}
                            }else if(split.length == 3) {
                                try {
                                    Double mp = Double.parseDouble(split[1] + "." + split[2]);
                                    Double chance = chances.get(oreType);
                                    chance = chance * mp;
                                    chances.put(oreType, chance);
                                }catch (NumberFormatException ex) {
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    public Material getRandomOre(HashMap<String, Double> oresInRange, String biome)// Generates a random ore based on the biome percentages.
    {
        HashMap<String,Double> chances = oresInRange;
        Double totalValue = 0.0;
        Double total_specifier = 0.0;

        for(String key : chances.keySet()) {
            totalValue += chances.get(key);
        }
        Double randomValue = (Math.random() * totalValue) + 0.0;
        Double addedValue = 0.0;
        for(String oreType : chances.keySet()) {
            if (addedValue + chances.get(oreType) >= randomValue) {
                if (oreType.equalsIgnoreCase("netherite")) return Material.ANCIENT_DEBRIS;
                if (oreType.equalsIgnoreCase("nether_gold")) return Material.NETHER_GOLD_ORE;
                if (oreType.equalsIgnoreCase("copper")) return Material.COPPER_ORE;
                if (oreType.equalsIgnoreCase("deepslate_iron")) return Material.DEEPSLATE_IRON_ORE;
                if (oreType.equalsIgnoreCase("deepslate_gold")) return Material.DEEPSLATE_GOLD_ORE;
                if (oreType.equalsIgnoreCase("deepslate_diamond")) return Material.DEEPSLATE_DIAMOND_ORE;
                if (oreType.equalsIgnoreCase("deepslate_lapis")) return Material.DEEPSLATE_LAPIS_ORE;
                if (oreType.equalsIgnoreCase("deepslate_coal")) return Material.DEEPSLATE_COAL_ORE;
                if (oreType.equalsIgnoreCase("deepslate_emerald")) return Material.DEEPSLATE_EMERALD_ORE;
                if (oreType.equalsIgnoreCase("deepslate_copper")) return Material.DEEPSLATE_COPPER_ORE;
                if (oreType.equalsIgnoreCase("nether_quartz")) return Material.NETHER_QUARTZ_ORE;
                if (oreType.equalsIgnoreCase("diamond")) return Material.DIAMOND_ORE;
                if (oreType.equalsIgnoreCase("gold")) return Material.GOLD_ORE;
                if (oreType.equalsIgnoreCase("emerald")) return Material.EMERALD_ORE;
                if (oreType.equalsIgnoreCase("redstone")) return Material.REDSTONE_ORE;
                if (oreType.equalsIgnoreCase("lapis_lazuli")) return Material.LAPIS_ORE;
                if (oreType.equalsIgnoreCase("coal")) return Material.COAL_ORE;
                if (oreType.equalsIgnoreCase("iron")) return Material.IRON_ORE;
                if (oreType.equalsIgnoreCase("nothing")) return Material.AIR;
            } else {
                addedValue += chances.get(oreType);
            }
        }
        return Material.AIR;
    }// End getRandomOre

    public BlockFace getClosestFace (float direction, float heightdirection){// Gets the face of the block the player is looking at.

        BlockFace face = BlockFace.DOWN;
        direction = direction % 360;

        if(heightdirection >= 45){
            face = BlockFace.DOWN;
            return face;
        }
        if(heightdirection <= -45){
            face = BlockFace.UP;
            return face;
        }
        if (direction < 0)
            direction += 360;

        direction = Math.round(direction / 45);

        switch ((int) direction) {

            case 0:
                face = BlockFace.SOUTH;
                break;
            case 1:
                if(Math.abs(direction)%45<=22.5){
                    face = BlockFace.SOUTH;
                }else{
                    face = BlockFace.WEST;
                }
                break;
            case 2:
                face = BlockFace.WEST;
                break;
            case 3:
                if(Math.abs(direction)%45<=22.5){
                    face = BlockFace.WEST;
                }else{
                    face = BlockFace.NORTH;
                }
                break;
            case 4:
                face = BlockFace.NORTH;
                break;
            case 5:
                if(Math.abs(direction)%45<=22.5){
                    face = BlockFace.NORTH;
                }else{
                    face = BlockFace.EAST;
                }
                break;
            case 6:
                face = BlockFace.EAST;
                break;
            case 7:
                if(Math.abs(direction)%45<=22.5){
                    face = BlockFace.SOUTH;
                }else{
                    face = BlockFace.EAST;
                }
                break;
            default:
                face = BlockFace.SOUTH;
        }
        return face;
    }// End getClosestFace

    public void spawnOres(int amount, Material type, Block block, BlockFace face){// Spawns ores given the parameters
                                                                                    // 1. amount - number of ores (1,2,4,8)
                                                                                    // 2. type - which Material type
                                                                                    // 3. block - starting block

        ArrayList<Block> blocks = new ArrayList<Block>();
        Block nextBlock = block;
        //BlockFace face = BlockFace.DOWN;
        Location location = block.getLocation();
        if(amount == 1){
            pasteIfSafe(block, type);
        }else if(amount == 2){
            pasteIfSafe(block, type);
            if(face == BlockFace.DOWN){
                nextBlock = block.getRelative(BlockFace.UP);
            }else{
                nextBlock = block.getRelative(BlockFace.DOWN);
            }
            pasteIfSafe(nextBlock,type);
        }else if(amount == 4){
            if(face == BlockFace.DOWN){
                location.setY(location.getY()  - 1);
                location.setX(location.getX() - 1);
                spawnOresInRange(location, block.getLocation(), type);
                return;
            }
            if(face == BlockFace.EAST){
                location.setX(location.getX() + 1);
                location.setY(location.getY()  + 1);
            }
            if(face == BlockFace.WEST){
                location.setX(location.getX() - 1);
                location.setY(location.getY()  + 1);
            }
            if(face == BlockFace.NORTH){
                location.setZ(location.getZ() - 1);
                location.setY(location.getY()  + 1);
            }
            if(face == BlockFace.SOUTH){
                location.setZ(location.getZ() + 1);
                location.setY(location.getY()  + 1);
            }
            if(face == BlockFace.UP){
                location.setY(location.getY()  + 1);
                location.setX(location.getX() - 1);
            }
            spawnOresInRange(block.getLocation(), location, type);
        }else if(amount == 8){
            if(face == BlockFace.DOWN){
                location.setY(location.getY()  - 1);
                location.setX(location.getX() - 1);
                location.setZ((location.getZ() - 1));
                spawnOresInRange(location, block.getLocation(), type);
                return;
            }
            if(face == BlockFace.EAST){
                location.setX(location.getX() + 1);
                location.setY(location.getY()  + 1);
                location.setZ((location.getZ() + 1));
            }
            if(face == BlockFace.WEST){
                location.setX(location.getX() - 1);
                location.setY(location.getY()  + 1);
                location.setZ((location.getZ() - 1));
            }
            if(face == BlockFace.NORTH){
                location.setZ(location.getZ() - 1);
                location.setY(location.getY()  + 1);
                location.setX((location.getX() - 1));
            }
            if(face == BlockFace.SOUTH){
                location.setZ(location.getZ() + 1);
                location.setY(location.getY()  + 1);
                location.setX((location.getX() + 1));
            }
            if(face == BlockFace.UP){
                location.setY(location.getY()  + 1);
                location.setX(location.getX() - 1);
                location.setZ(location.getZ() + 1);
            }
            spawnOresInRange(block.getLocation(), location, type);// Spawns ores between the two created locations.
        }
    }// End spawnOres

    private void pasteIfSafe(Block block, Material type){// Will spawn ores if the block fulfills these requirements:
                                                         // 1. Block being replaced is either Stone or NetherRack
                                                         // 2. The new type isn't Material.AIR
                                                         // 3. Block is not exposed to air
        if((block.getType() == Material.STONE || block.getType() == Material.NETHERRACK) && type != Material.AIR && validateBlock(block)){
            if(!block.getMetadata("canBeReplaced").isEmpty() || !block.getMetadata("isProtected").isEmpty()){
                return;
            }
            block.setType(type);
            block.setMetadata("canBeReplaced", new FixedMetadataValue(plugin,false));// Sets the metadata canBeReplaced to false
                                                                                                   // Meaning that the plugin cannot remove it when players are mining.
        }
    }// End pasteIfSafe

    private void spawnOresInRange(Location start, Location end, Material type){// Spawns ores in a cuboid range defined by two locations.
        int startx = start.getBlockX();
        int starty = start.getBlockY();
        int startz = start.getBlockZ();

        int endx = end.getBlockX();
        int endy = end.getBlockY();
        int endz = end.getBlockZ();

        ArrayList<Integer> starters = new ArrayList<Integer>(); //x y z
        ArrayList<Integer> enders = new ArrayList<Integer>();

        if(startx>= endx){
            starters.add(startx);
            enders.add(endx);
        }else{
            starters.add(endx);
            enders.add(startx);
        }
        if(starty>= endy){
            starters.add(starty);
            enders.add(endy);
        }else{
            starters.add(endy);
            enders.add(starty);
        }
        if(startz>= endz){
            starters.add(startz);
            enders.add(endz);
        }else{
            starters.add(endz);
            enders.add(startz);
        }
        for (int i = starters.get(0); i>= enders.get(0); i--)
        {
            for (int j =starters.get(1); j>= enders.get(1); j--)
            {
                for (int k =starters.get(2);k>= enders.get(2); k--)
                {
                    Block b = start.getWorld().getBlockAt(i,j,k);
                    pasteIfSafe(b, type);
                }
            }
        }

    }// End spawnOresInRange

    public int generateOreSize(String oretype){// Generates an ore size based on config % for that ore.
        if(oretype == "nothing"){
            return 1;
        }
        int size = 1;
        HashMap<String, Double> chances = new HashMap<>();// Stores chances for each size.
        double totalvalue = 0;// Accumulating Variable to get the range for the Random variable.
        if(!plugin.getConfig().isSet("ore-sizes-chances." + oretype)){
            files.logError("ore-sizes-chances."+ oretype + " doesn't exist in the config, " +
                    "therefore the plugin cannot accurately generate a size. Generating default (1)");
            sendConsole("ore-sizes-chances."+ oretype + " doesn't exist in the config.yml, " +
                    "therefore the plugin cannot accurately generate a size. Generating default (1)");
            return 1;
        }
        for(String key : plugin.getConfig().getConfigurationSection("ore-sizes-chances." + oretype).getKeys(false)){
            double chance = plugin.getConfig().getDouble("ore-sizes-chances." + oretype + "."+ key);// Key is the ore-size.
            chances.put(key,chance);
            totalvalue += chance;
        }
        Double randomValue = (Math.random() * totalvalue) + 0.0;
        double addedValue = 0.0;
        for(String chance : chances.keySet()) {
            if (addedValue + chances.get(chance) >= randomValue) {
                    return Integer.parseInt(chance);
            }else{
                addedValue += chances.get(chance);
            }
        }
        return size;
    }// End generateOreSize

    public String fromMaterialToString(Material type){
        if (type == Material.ANCIENT_DEBRIS) return "netherite";
        if (type == Material.NETHER_GOLD_ORE) return "nether_gold";
        if (type == Material.NETHER_QUARTZ_ORE) return "nether_quartz";
        if (type == Material.DIAMOND_ORE) return "diamond";
        if (type == Material.GOLD_ORE) return "gold";
        if (type == Material.EMERALD_ORE) return "emerald";
        if (type == Material.REDSTONE_ORE) return "redstone";
        if (type == Material.COAL_ORE) return "coal";
        if (type == Material.IRON_ORE) return "iron";
        if (type == Material.LAPIS_LAZULI) return "lapis_lazuli";
        if (type == Material.COPPER_ORE) return "copper";
        if (type == Material.DEEPSLATE_IRON_ORE) return "deepslate_iron";
        if (type == Material.DEEPSLATE_GOLD_ORE) return "deepslate_gold";
        if (type == Material.DEEPSLATE_DIAMOND_ORE) return "deepslate_diamond";
        if (type == Material.DEEPSLATE_LAPIS_ORE) return "deepslate_lapis";
        if (type == Material.DEEPSLATE_COAL_ORE) return "deepslate_coal";
        if (type == Material.DEEPSLATE_EMERALD_ORE) return "deepslate_emerald";
        if (type == Material.DEEPSLATE_COPPER_ORE) return "deepslate_copper";
        return "nothing";
    }// End fromMaterialToString

    public void sendConsole(String message){
        if (plugin.getConfig().isSet("console-errors")) {
            Bukkit.getConsoleSender().sendMessage(ChatColor.RED + message);
        } else {
            files.logError("console-errors is missing from the config.yml. This might be why no errors are apearing in the console");
        }
    }
}
